package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"

	"github.com/dclappert/protoc-gen-salesforce-apex/internal/optionsparser"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

const MESSAGE_TEMPLATE_STRING = `/**
* DO NOT EDIT
* Generated by protoc-gen-salesforce-apex
* Source Proto File: {{ .Package.Name }} 
* Source Message: {{ .Message.Name }}
* /

global class {{ .Message.Name }} {

{{- range $enumIndex, $enum := .Message.EnumType }}
    global enum {{ $enum.Name }} { 
        {{- $last := sub (len $enum.Value) 1 }}
        {{- range $enumValueIndex, $enumValue := $enum.Value }}
        {{ $enumValue.Name }}{{ if lt $enumValueIndex $last }},{{ end }}
        {{- end }}
    }
{{- end }}

{{- range .Message.Field }}
    global {{ propertyType $.Package $.Message . }} {{ getFieldName . }};
{{- end }}

{{- if gt (len .Message.NestedType) 0 }}
    {{- range .Message.NestedType }}
        {{- if not (isNestedTypeAMap .) }}
    global class {{ .Name }} {
            {{- range .Field }}
        global {{ propertyType $.Package $.Message . }} {{ getFieldName . }};
            {{- end }}
    }
        {{- end }}
    {{- end }}
{{- end }}
}
`

const CLASS_METADATA_TEMPLATE_STRING = `<?xml version="1.0" encoding="UTF-8"?>
<ApexClass xmlns="http://soap.sforce.com/2006/04/metadata">
    <apiVersion>{{ .ApiVersion }}</apiVersion>
    <status>Active</status>
</ApexClass>`

type classTemplateBind struct {
	Package *descriptorpb.FileDescriptorProto
	Message *descriptorpb.DescriptorProto
}

type classMetadataTemplateBind struct {
	ApiVersion *string
}

var (
	options               *optionsparser.Options
	classTemplate         *template.Template
	classMetadataTemplate *template.Template
	mapTypeDefinitionsMap map[string]*descriptorpb.DescriptorProto
)

func main() {
	initializeApexClassTemplate()
	initializeApexClassMetadataTemplate()
	codeGeneratorRequest := toCodeGeneratorRequest(os.Stdin)
	options = optionsparser.ParseOptions(codeGeneratorRequest.GetParameter())
	createMapTypeDefinitionsMap(codeGeneratorRequest)
	emitCodeGeneratorResponse(generateApex(codeGeneratorRequest))
}

func initializeApexClassTemplate() {
	var err error
	classTemplate, err = template.New("message").Funcs(template.FuncMap{
		"sub":              sub,
		"propertyType":     getPropertyType,
		"getFieldName":     getFieldName,
		"isNestedTypeAMap": isNestedTypeAMap,
	}).Parse(MESSAGE_TEMPLATE_STRING)
	if err != nil {
		panic(err)
	}
}

func initializeApexClassMetadataTemplate() {
	var err error
	classMetadataTemplate, err = template.New("classMetadata").Parse(CLASS_METADATA_TEMPLATE_STRING)
	if err != nil {
		panic(err)
	}
}

func sub(x int, y int) int {
	return x - y
}

func getPropertyType(protoFile *descriptorpb.FileDescriptorProto, message *descriptorpb.DescriptorProto, field *descriptorpb.FieldDescriptorProto) string {
	if isMap(protoFile, message, field) {
		mapTypeDefinition := mapTypeDefinitionsMap[fromFieldToMapTypeDefinitionKey(protoFile, message, field)]
		keyType := getType(mapTypeDefinition.Field[0], protoFile.GetPackage())
		valueType := getType(mapTypeDefinition.Field[1], protoFile.GetPackage())
		return fmt.Sprintf("Map<%s, %s>", keyType, valueType)
	} else if isCollection(field) {
		return fmt.Sprintf("List<%s>", getType(field, protoFile.GetPackage()))
	} else {
		return fmt.Sprintf("%s", getType(field, protoFile.GetPackage()))
	}
}

func getFieldName(field *descriptorpb.FieldDescriptorProto) string {
	if options.UseProtoFieldNames {
		return field.GetName()
	}
	return field.GetJsonName()
}

func isMap(Package *descriptorpb.FileDescriptorProto, message *descriptorpb.DescriptorProto, field *descriptorpb.FieldDescriptorProto) bool {
	key := fromFieldToMapTypeDefinitionKey(Package, message, field)
	if _, ok := mapTypeDefinitionsMap[key]; ok {
		return ok
	}
	return false
}

func isCollection(f *descriptorpb.FieldDescriptorProto) bool {
	return f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED
}

func getType(f *descriptorpb.FieldDescriptorProto, packageName string) string {
	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return "String"
	case descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return "Integer"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "Boolean"
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE,
		descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		return "Double"
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE,
		descriptorpb.FieldDescriptorProto_TYPE_ENUM:
		if f.GetTypeName() == ".google.protobuf.Any" {
			return "Object"
		}
		return strings.Replace(f.GetTypeName(), "."+packageName+".", "", -1)
	}
	panic("Unknown Type: " + f.GetTypeName())
}

func toCodeGeneratorRequest(r io.Reader) *pluginpb.CodeGeneratorRequest {
	buf, err := io.ReadAll(r)
	if err != nil {
		panic(err)
	}

	var codeGeneratorRequest pluginpb.CodeGeneratorRequest
	if err = proto.Unmarshal(buf, &codeGeneratorRequest); err != nil {
		panic(err)
	}
	return &codeGeneratorRequest
}

func generateApex(req *pluginpb.CodeGeneratorRequest) *pluginpb.CodeGeneratorResponse {
	protoFiles := getProtoFiles(req)
	var resp pluginpb.CodeGeneratorResponse
	for _, fileName := range req.FileToGenerate {
		protoFile := protoFiles[fileName]
		for _, message := range protoFile.MessageType {
			resp.File = appendApexClassFile(resp.File, message, protoFile)
			resp.File = appendApexClassMetadataFile(resp.File, message)
		}
	}
	return &resp
}

func createMapTypeDefinitionsMap(req *pluginpb.CodeGeneratorRequest) {
	mapTypeDefinitionsMap = make(map[string]*descriptorpb.DescriptorProto)
	protoFiles := getProtoFiles(req)
	for _, fileName := range req.FileToGenerate {
		protoFile := protoFiles[fileName]
		for _, message := range protoFile.MessageType {
			for _, nestedType := range message.NestedType {
				if !isNestedTypeAMap(nestedType) {
					continue
				}
				mapTypeDefinitionsMap[fromNestTypeToMapTypeDefinitionKey(protoFile, message, nestedType)] = nestedType
			}
		}
	}
}

// isNestedTypeAMap checks if a given nested type in a Protobuf message represents a map.
// It returns true if the nested type has exactly two fields named 'key' and 'value',
// which is the typical structure for map entries in Protobuf.
//
// Parameters:
// nestedType - A pointer to a DescriptorProto representing the nested type.
//
// Returns:
// A boolean indicating whether the nested type represents a map.
func isNestedTypeAMap(nestedType *descriptorpb.DescriptorProto) bool {
	return len(nestedType.Field) == 2 && nestedType.Field[0].GetName() == "key" && nestedType.Field[1].GetName() == "value"
}

// fromNestTypeToMapTypeDefinitionKey generates a unique string key for a map type definition in a Protobuf file.
// The key is composed of the package name, message name, and nested type name (with "Entry" removed),
// all converted to lower case and concatenated with dots.
//
// Parameters:
// protoFile - A pointer to the FileDescriptorProto where the map type is defined.
// message - A pointer to the DescriptorProto for the message that contains the map.
// nestedType - A pointer to the DescriptorProto representing the map's nested type.
//
// Returns:
// A string representing the unique key for the map type definition.
func fromNestTypeToMapTypeDefinitionKey(protoFile *descriptorpb.FileDescriptorProto, message *descriptorpb.DescriptorProto, nestedType *descriptorpb.DescriptorProto) string {
	return strings.ToLower(protoFile.GetPackage()) + "." + strings.ToLower(message.GetName()) + "." + strings.ToLower(strings.Replace(nestedType.GetName(), "Entry", "", -1))
}

// fromFieldToMapTypeDefinitionKey generates a unique string key for a map type definition
// based on the provided Protobuf file, message, and field. The key is composed of the
// package name, message name, and the JSON name of the field, all converted to lower case
// and concatenated with dots. This function is typically used to create a consistent
// identifier for a specific field within a Protobuf message, especially useful for map fields.
//
// Parameters:
//
//	protoFile - A pointer to the FileDescriptorProto where the field is defined.
//	message - A pointer to the DescriptorProto for the message that contains the field.
//	field - A pointer to the FieldDescriptorProto representing the field in the message.
//
// Returns:
//
//	A string representing the unique key for the field's map type definition.
func fromFieldToMapTypeDefinitionKey(protoFile *descriptorpb.FileDescriptorProto, message *descriptorpb.DescriptorProto, field *descriptorpb.FieldDescriptorProto) string {
	return strings.ToLower(protoFile.GetPackage()) + "." + strings.ToLower(message.GetName()) + "." + strings.ToLower(field.GetJsonName())
}

// getProtoFiles creates a map of file names to their corresponding FileDescriptorProto objects
// from a CodeGeneratorRequest. This map can be used to quickly access file descriptors by their names.
//
// Parameters:
// req - A pointer to a CodeGeneratorRequest which contains the list of Proto files.
//
// Returns:
// A map where the keys are file names and the values are pointers to FileDescriptorProto objects.
func getProtoFiles(req *pluginpb.CodeGeneratorRequest) map[string]*descriptorpb.FileDescriptorProto {
	files := make(map[string]*descriptorpb.FileDescriptorProto)
	for _, f := range req.ProtoFile {
		files[f.GetName()] = f
	}
	return files
}

func appendApexClassFile(file []*pluginpb.CodeGeneratorResponse_File, message *descriptorpb.DescriptorProto, protoFile *descriptorpb.FileDescriptorProto) []*pluginpb.CodeGeneratorResponse_File {
	b := bytes.NewBuffer([]byte{})
	err := classTemplate.Execute(b, classTemplateBind{Message: message, Package: protoFile})
	if err != nil {
		panic(err)
	}
	return append(file, &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(message.GetName() + ".cls"),
		Content: proto.String(b.String()),
	})
}

func appendApexClassMetadataFile(file []*pluginpb.CodeGeneratorResponse_File, message *descriptorpb.DescriptorProto) []*pluginpb.CodeGeneratorResponse_File {
	b := bytes.NewBuffer([]byte{})
	err := classMetadataTemplate.Execute(b, classMetadataTemplateBind{ApiVersion: &options.ApiVersion})
	if err != nil {
		panic(err)
	}
	return append(file, &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(message.GetName() + ".cls-meta.xml"),
		Content: proto.String(b.String()),
	})
}

func emitCodeGeneratorResponse(resp *pluginpb.CodeGeneratorResponse) {
	buf, err := proto.Marshal(resp)
	if err != nil {
		panic(err)
	}
	_, err = os.Stdout.Write(buf)
	if err != nil {
		panic(err)
	}
}
