package apexclass

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/dclappert/protoc-gen-salesforce-apex/internal/maptypedefinitions"
	"github.com/dclappert/protoc-gen-salesforce-apex/internal/optionsparser"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

const MESSAGE_TEMPLATE_STRING = `/**
* DO NOT EDIT
* Generated by protoc-gen-salesforce-apex
* Source Proto File: {{ .Package.Name }} 
* Source Message: {{ .Message.Name }}
*/

global class {{ .Message.Name }} {

{{- range $enumIndex, $enum := .Message.EnumType }}
    global enum {{ $enum.Name }} { 
        {{- $last := sub (len $enum.Value) 1 }}
        {{- range $enumValueIndex, $enumValue := $enum.Value }}
        {{ $enumValue.Name }}{{ if lt $enumValueIndex $last }},{{ end }}
        {{- end }}
    }
{{- end }}

{{- range .Message.Field }}
    global {{ propertyType $.Package $.Message . }} {{ getFieldName . }};
{{- end }}

{{- if gt (len .Message.NestedType) 0 }}
    {{- range .Message.NestedType }}
        {{- if not (isNestedTypeAMap .) }}
    global class {{ .Name }} {
            {{- range .Field }}
        global {{ propertyType $.Package $.Message . }} {{ getFieldName . }};
            {{- end }}
    }
        {{- end }}
    {{- end }}
{{- end }}
}
`

type classTemplateBind struct {
	Package *descriptorpb.FileDescriptorProto
	Message *descriptorpb.DescriptorProto
}

type FromParams struct {
	Message              *descriptorpb.DescriptorProto
	ProtoFile            *descriptorpb.FileDescriptorProto
	CodeGeneratorRequest *pluginpb.CodeGeneratorRequest
}

type ApexClass struct {
	classTemplate      *template.Template
	options            *optionsparser.Options
	mapTypeDefinitions *maptypedefinitions.MapTypeDefinitions
	params             *FromParams
}

func New(params *FromParams) *ApexClass {
	apexClass := &ApexClass{
		params:             params,
		classTemplate:      template.New("message"),
		options:            optionsparser.ParseOptions(params.CodeGeneratorRequest.GetParameter()),
		mapTypeDefinitions: maptypedefinitions.CreateFrom(params.CodeGeneratorRequest),
	}

	apexClass.classTemplate.Funcs(template.FuncMap{
		"sub":              sub,
		"propertyType":     apexClass.getPropertyType,
		"getFieldName":     apexClass.getFieldName,
		"isNestedTypeAMap": isNestedTypeAMap,
	}).Parse(MESSAGE_TEMPLATE_STRING)

	return apexClass
}

func (ac *ApexClass) GetFile() *pluginpb.CodeGeneratorResponse_File {
	b := bytes.NewBuffer([]byte{})
	err := ac.classTemplate.Execute(b, classTemplateBind{Message: ac.params.Message, Package: ac.params.ProtoFile})
	if err != nil {
		panic(err)
	}
	return &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(ac.params.Message.GetName() + ".cls"),
		Content: proto.String(b.String()),
	}
}

func sub(x int, y int) int {
	return x - y
}

func (ac *ApexClass) getPropertyType(protoFile *descriptorpb.FileDescriptorProto, message *descriptorpb.DescriptorProto, field *descriptorpb.FieldDescriptorProto) string {
	if ac.isMap(protoFile, message, field) {
		mapTypeDefinition := ac.mapTypeDefinitions.Get(fromFieldToMapTypeDefinitionKey(protoFile, message, field))
		keyType := getType(mapTypeDefinition.Field[0], protoFile.GetPackage())
		valueType := getType(mapTypeDefinition.Field[1], protoFile.GetPackage())
		return fmt.Sprintf("Map<%s, %s>", keyType, valueType)
	} else if isCollection(field) {
		return fmt.Sprintf("List<%s>", getType(field, protoFile.GetPackage()))
	} else {
		return fmt.Sprintf("%s", getType(field, protoFile.GetPackage()))
	}
}

func (ac *ApexClass) getFieldName(field *descriptorpb.FieldDescriptorProto) string {
	if ac.options.UseProtoFieldNames {
		return field.GetName()
	}
	return field.GetJsonName()
}

func (ac *ApexClass) isMap(Package *descriptorpb.FileDescriptorProto, message *descriptorpb.DescriptorProto, field *descriptorpb.FieldDescriptorProto) bool {
	key := fromFieldToMapTypeDefinitionKey(Package, message, field)
	return ac.mapTypeDefinitions.Has(key)
}

func isCollection(f *descriptorpb.FieldDescriptorProto) bool {
	return f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED
}

func getType(f *descriptorpb.FieldDescriptorProto, packageName string) string {
	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_STRING:
		return "String"
	case descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return "Integer"
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "Boolean"
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE,
		descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		return "Double"
	case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE,
		descriptorpb.FieldDescriptorProto_TYPE_ENUM:
		if f.GetTypeName() == ".google.protobuf.Any" {
			return "Object"
		}
		return strings.Replace(f.GetTypeName(), "."+packageName+".", "", -1)
	}
	panic("Unknown Type: " + f.GetTypeName())
}

// fromFieldToMapTypeDefinitionKey generates a unique string key for a map type definition
// based on the provided Protobuf file, message, and field. The key is composed of the
// package name, message name, and the JSON name of the field, all converted to lower case
// and concatenated with dots. This function is typically used to create a consistent
// identifier for a specific field within a Protobuf message, especially useful for map fields.
//
// Parameters:
//
//	protoFile - A pointer to the FileDescriptorProto where the field is defined.
//	message - A pointer to the DescriptorProto for the message that contains the field.
//	field - A pointer to the FieldDescriptorProto representing the field in the message.
//
// Returns:
//
//	A string representing the unique key for the field's map type definition.
func fromFieldToMapTypeDefinitionKey(protoFile *descriptorpb.FileDescriptorProto, message *descriptorpb.DescriptorProto, field *descriptorpb.FieldDescriptorProto) string {
	return strings.ToLower(protoFile.GetPackage()) + "." + strings.ToLower(message.GetName()) + "." + strings.ToLower(field.GetJsonName())
}

// isNestedTypeAMap checks if a given nested type in a Protobuf message represents a map.
// It returns true if the nested type has exactly two fields named 'key' and 'value',
// which is the typical structure for map entries in Protobuf.
//
// Parameters:
// nestedType - A pointer to a DescriptorProto representing the nested type.
//
// Returns:
// A boolean indicating whether the nested type represents a map.
func isNestedTypeAMap(nestedType *descriptorpb.DescriptorProto) bool {
	return len(nestedType.Field) == 2 && nestedType.Field[0].GetName() == "key" && nestedType.Field[1].GetName() == "value"
}
